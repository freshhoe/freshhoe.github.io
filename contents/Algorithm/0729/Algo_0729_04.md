---
date: '2021-07-29'
title: '[JS Algo] 연속 부분수열 2'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 연속 부분수열 2

<details>
<summary></summary>
<div markdown="1">       
N 개의 수로 이루어진 수열이 주어집니다. 이때 수열의 연속된 부분 수열의 합 중에서 목표로 하는 M 값을 갖는 모든 연속부분수열의 갯수를 반환해야 합니다.<br>
단, 수열에 수에 음수가 포함되어 있습니다.
</div>
</details>

## A. 풀이

연속 부분수열1과 유사한 문제입니다. 수열에 음수가 포함되어 있으므로 다른 방식을 취해야 합니다. `Two pointers` 를 사용할 수 없습니다. 대신에 `Map` 객체와 누적합, 그리고 이 누적합과 관련된 idea를 사용해 목표값과 일치하는 수열의 합의 갯수를 파악합니다. 수열의 처음부터 차례대로 값을 조회하며 합을 누적시킵니다. 동시에 `Map` 에 해당 합의 종류를 `key` 로, 갯수를 `value`로 카운트 해서 기록합니다. 누적합 자체가 목표값 `m`과 일치하면 결과변수에 반영합니다. 그렇지 않을 경우, 누적합이 목표값을 `sum - m` 만큼 넘어버렸다는 말이됩니다. 따라서 누적합에서 목표값을 뺀 `sum - m` 의 값을 `key` 로 가진 객체가 있는지 `Map` 에서 조회하고 해당 `key` 의 `value`를 결과변수에 반영합니다.

```javascript
// 연속 부분수열 2 (양수말고 음수도 포함되어 있다!)
// lt, rt 를 사용하지 않아야 하는 반례 문제에 해당. 투 포인터 사용 안함
// 해쉬맵을 만들어야 함.
function solution(nums, m) {
  let answer = 0;
  let sum = 0; // 빼는 게 없는 첫 원소부터 계속 값을 누적해나가는 변수(only 누적합)
  let nH = new Map();

  for (let i = 0; i < nums.length; i++) {
    sum += nums[i];
    if (sum === m) answer++; // 누적합이 target value 가 되는가
    if (nH.has(sum - m)) answer += nH.get(sum - m);
    nH.set(sum, nH.get(sum) + 1 || 1);
  }

  return answer;
}
console.log(solution([1, 2, 3, -3, 1, 2], 3)); // 6
console.log(solution([-1, 0, 1], 0)); // 2
console.log(solution([-1, -1, -1, 1], 0)); // 1
```

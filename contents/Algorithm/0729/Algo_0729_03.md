---
date: '2021-07-29'
title: '[JS Algo] 연속 부분수열'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 연속 부분수열

<details>
<summary></summary>
<div markdown="1">       
N 개의 수로 이루어진 수열이 주어집니다. 이때 수열의 연속된 부분 수열의 합 중에서 목표로 하는 M 값을 갖는 모든 연속부분수열의 갯수를 반환해야 합니다. 
</div>
</details>

## A. 풀이

`two pointers` 알고리즘을 활용합니다. 슬라이딩 윈도우와의 차이점은 `start` 포인트와 `end` 포인트의 길이 유지 여부입니다. `two pointers` 알고리즘은 조건에 따라 `end` 포인트만 증가시키거나 `start` 포인트만 증가시킵니다. 두 포인터의 시작은 같습니다. `end` 포인트 인덱스의 값은 하나씩 증가합니다. 연속부분수열 합의 값이 우리가 목표로 하는 값 `m` 보다 크다면 목표값 `m`과 같거나 작을때까지 `start` 포인트 인덱스를 증가시키고, 앞서 더한 `start` 포인트 인덱스의 값을 합계에서 빼줍니다. 이 과정을 배열의 끝까지 반복하며 목표값 `m` 과 일치하는 합계만 갯수로 세서 결과변수에 할당해 반환합니다.

```javascript
function solution(nums, m) {
  let answer = 0;
  let sum = 0;
  let lt = 0;
  for (let rt = 0; rt < nums.length; rt++) {
    // 인덱스 증가하는 반복문 한 번 수행 후 증가하는 것.
    sum += nums[rt];
    if (sum === m) answer++; // sum 에 대한 변화를 주는 코드 다음에는 조건문으로 확인 과정이 필요함.
    while (sum > m) {
      sum -= nums[lt]; // sum -= nums[lt++]; 와 동일
      lt++;
      if (sum === m) answer++;
    }
  }
  return answer;
}
console.log(solution([1, 2, 1, 3, 1, 1, 1, 2], 6)); // 3
console.log(solution([1, 1, 1, 1, 1, 1], 3)); // 4
console.log(solution([1, 2, 1, 2, 1, 2, 1], 3)); // 6
```

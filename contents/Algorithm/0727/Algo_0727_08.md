---
date: '2021-07-27'
title: '[JS Algo] 봉우리'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 봉우리

<details>
<summary></summary>
<div markdown="1">
N * N 2차원 배열에서 특정 원소가 원소의 상하좌우 원소의 값 보다 큰 값일 경우 봉우리가 됩니다. 배열에서 봉우리에 해당하는 원소는 몇 개인지 알 수 있는 프로그램을 작성하세요.
</div>
</details>

## A. 풀이

2차원 배열의 원소를 조회할 때마다 해당 원소의 상하좌우 값을 탐색하며 대소비교를 해야합니다. 행 방향, 열 방향 조회 인덱스를 초기화 해두면 탐색이 편해집니다. 조회 인덱스를 사용해 2차원 배열 원소의 상하좌우 값을 각각 탐색할 때마다 해당 원소와 대소비교를 진행하고 상하좌우값 중 더 큰 값이 있을 경우 봉우리가 아니므로 배열의 다음 원소 조회로 넘어갑니다. 이 때 배열의 경계에 있는 원소들은 경계밖으로 넘어가 값을 비교하지 않도록 범위 제약조건을 걸어줍니다. 또한 `flag` 를 사용해 우리가 조회한 배열의 원소 보다 큰 값이 상하좌우 값에 있을 경우 `answer` 에 추가하지 않도록 합니다.

```javascript
function solution(nums) {
  let answer = 0;
  let N = nums.length;
  let dx = [-1, 0, 1, 0]; // 행 방향 조회 인덱스 초기화
  let dy = [0, 1, 0, -1]; // 열 방향 조회 인덱스 초기화
  // 위쪽 부터 시계방향
  // dx, dy [-1, 0] : 현재 조회된 2차원 배열 원소(i,j)의 위쪽 값
  // dx, dy [0, 1] : 현재 조회된 2차원 배열 원소(i,j)의 오른쪽 값
  // dx, dy [1, 0] : 현재 조회된 2차원 배열 원소(i,j)의 아래쪽 값
  // dx, dy [0, -1] : 현재 조회된 2차원 배열 원소(i,j)의 왼쪽 값
  // 만약 8방향을 조회하라고 하면 추가로 dx, dy 초기화 해놓고 시작

  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j++) {
      let flag = true;
      for (let k = 0; k < 4; k++) {
        let nx = i + dx[k];
        let ny = j + dy[k];
        if (
          nx >= 0 && // 경계선 벗어남 여부 확인 조건
          nx < N &&
          ny >= 0 &&
          ny < N &&
          nums[nx][ny] >= nums[i][j]
        ) {
          flag = false;
          break;
        }
      }
      if (flag) answer++;
    }
  }
  return answer;
}
console.log(
  solution([
    [5, 3, 7, 2, 3],
    [3, 7, 1, 6, 1],
    [7, 2, 5, 3, 4],
    [4, 3, 6, 4, 1],
    [8, 7, 3, 5, 2],
  ]),
); // 10
```

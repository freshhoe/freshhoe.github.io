---
date: '2021-07-27'
title: '[JS Algo] 거리 두기'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 거리 두기

<details>
<summary></summary>
<div markdown="1">

## 일렬로된 좌석정보가 주어지면, 이미 앉아 있는 사람들 중 가장 가까운 사람과 최대한 멀리 떨어져 앉을 좌석을 선택해야 합니다. <br>

<출력설명>
ex) [1, 0, 0, 0, 1, 0, 0, 1, 0, 1]
총 10개의 좌석이 왼쪽부터 0번 좌석으로 해서 9번 좌석까지 존재한다면 2번 좌석에 앉으면 가장 가까운 사람과의 거리가 2가 됩니다.
만약 6번 좌석에 앉으면 가장 가까운 사람과의 거리는 1입니다.

</div>
</details>

## A. 풀이

양쪽 거리를 모두 고려해야 합니다. 따라서 왼쪽에서부터의 거리와 오른쪽에서부터의 거리를 측정해 최소값을 할당하면 됩니다.
이렇게 최소값 기준의 할당을 할 경우, 먼저 측정된 거리에 의해 나중에 측정된 거리가 갱신이 되지 않을 수 있으므로 거리값 초기화가 필요합니다.
거리가 모두 측정되면 거리값 중 최대값을 반환합니다.
이를 위해 거리값이 할당되는 배열과 거리값이 누적되는 변수를 생성합니다. 주어진 배열에서 값이 `1` 일 경우 거리값은 `0` 이 됩니다.
배열 내 값이 `0` 일경우 거리값은 `1` 이 할당되며 연속적으로 `0` 일 경우 거리값은 `1` 씩 누적됩니다.
나중에 측정되는 방향(아래에서는 오른쪽)에서 거리값을 할당할 때는 먼저 측정된 거리값(아래에서는 왼쪽)과 비교해 최소값을 할당합니다.
이렇게 할당된 거리값 배열에서 최대값을 반환합니다.

```javascript
function solution(nums) {
  let answer;
  let N = nums.length;
  let distArr = Array.from({ length: 10 }, () => 0);
  let d = 1000;

  for (let i = 0; i < N; i++) {
    if (nums[i] === 1) {
      d = 0;
      distArr[i] = d;
    } else {
      d++;
      distArr[i] = d;
    }
  }

  let d = 1000;
  for (let j = N - 1; j >= 0; j--) {
    if (nums[j === 1]) {
      d = 0;
    } else {
      d++;
      distArr[i] = Math.min(distArr[i], d);
    }
  }
  answer = Math.max(...distArr);
  return answer;
}
console.log(solution([1, 0, 0, 0, 1, 0, 0, 1, 0, 1])); // 2
```

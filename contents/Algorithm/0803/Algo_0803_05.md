---
date: '2021-08-03'
title: '[JS Algo] 최대 선호 음식 (DFS)'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 최대 선호 음식 (DFS)

<details>
<summary></summary>
<div markdown="1">       
선생님들이 가지고 있는 양념재료는 D 종류이며, 1 부터 D까지 번호가 부여되어 있습니다. N명의 학생들은 자신이 원하는 재료가 다 들어가야만 음식을 먹습니다. <br>
선생님들이 사용할 수 있는 재료의 종류가 K(1 <= K <= D)개 이하가 되도록 하려 합니다. 조건을 만족하면서 최대 몇 명의 학생에게 음식을 줄 수 있는지를 반환해야 합니다.
</div>
</details>

## A. 풀이
비트 연산을 활용합니다. 재료에 가중치를 부여합니다. 재료가 4개라면 1 ~ 4 번의 재료에 각각 1, 2, 4, 8 의 가중치를 부여합니다. 이렇게 할 경우 선생님이 보유한 재료의 가중치 합이, 보유 여부를 1 또는 0 으로 나타낸 이진수를 십진수로 표현한 값과 같습니다. 학생의 선호 재료 또한 마찬가지의 과정을 거칩니다. <br>
선생님이 보유한 재료와 학생이 선호하는 재료의 각각의 가중치 합을 비트 연산(`&`)을 수행했을 때, 학생이 선호하는 재료의 가중치 합이 도출된다면, 학생이 선호하는 재료의 종류는 선생님이 보유한 재료의 종류의 부분집합이 됩니다. 따라서 선생님이 보유한 재료로 해당 학생에게 음식을 먹일 수 있게 됩니다. 문제에서는 `D` 종류의 재료 중 제한된 `K` 개의 재료로 최대한 많은 학생을 먹일 수 있어야 합니다. <br>
`DFS` 를 활용해 최적의 `K` 재료의 조합을 찾아낼 수 있습니다. `DFS` 로 재료의 조합을 변경하고, 비트 연산으로 학생을 먹일 수 있는지 여부를 카운트해 최대의 카운트 값을 반환하면 됩니다. 

```javascript
function solution (nums, d, k) {
    let answer = Number.MIN_SAFE_INTEGER;
    let n = nums.length;
    let pow = Array.from({length: d + 1}, () => 0);
    let st = Array.from({length: n}, () => 0);
    pow[1] = 1;
    
    // i 인덱스가 양념 번호. pow 는 각 양념에 대한 가중치 배열 
    for (let i = 2; i <= d; i++) {
        pow[i] = pow[i - 1] * 2;
    }

    // nums에서 i 번째 학생이 선호하는 양념들의 가중치 합
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < nums[i].length; j++) {
            st[i] += pow[nums[i][j]]; // i 번 학생의 j 번째 양념 가중치
        }
    }
    // bit 는 선생님이 가진 양념의 가중치 합 
    // 어떤 양념을 가지고 있냐에 따라 값이 달라짐. 
    // DFS 로 최대 인원을 먹일 수 있는 재료의 조합을 찾아내는 것. 
    function DFS (L, s, bit) {
        if (L === k) {
            let cnt = 0;
            for (let j = 0; j < n; j++) {
                // 학생 선호 양념과 선생님이 가진 양념 비트연산(&)
                let tmp = bit & st[j];
                if ((bit & st[j]) === st[j]) cnt++;
            }
            answer = Math.max(answer, cnt);
        } else {
            // i 인덱스는 양념 번호
            for (let i = s; i <= d; i++) {
                DFS(L + 1, i + 1, bit + pow[i]);
            }
        }
    }
    DFS(0, 1, 0)
    return answer;
}
console.log(solution([[1], [2, 3], [3], [1, 2], [], 
                      [2, 1], [2, 3, 4], [3, 4]], 4, 3)) // 6
```
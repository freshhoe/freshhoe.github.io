---
date: '2021-08-03'
title: '[JS Algo] 토마토 (BFS)'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 토마토 (BFS)

<details>
<summary></summary>
<div markdown="1">       
격자판 형태의 창고에 익은 토마토와 익지 않은 토마토를 보관하고 있습니다. 익은 토마토의 상하좌우 인접한 곳에 익지 않은 토마토가 있다면 보관 후 하루가 지났을 때, 익은 토마토가 됩니다. 창고에 보관된 토마토가 며칠이 지나야 다 익게 되는지 그 최소 일수를 반환해야 합니다.<br>
익은 토마토는 1, 익지 않은 토마토는 0, 빈 곳은 -1 값을 갖습니다. 처음 저장될 때부터 모두 익어있다면 0, 토마토가 모두 익지 못하는 경우는 -1 을 반환합니다. 
</div>
</details>

## A. 풀이
행과 열 길이가 다름에 주의해야합니다. 거리배열을 만들어 `0` 으로 초기화 해둡니다. 다음에 탐색할 위치의 좌표값`[x, y]`을 할당하기 위해 `queue`를 사용합니다. 탐색의 시작이 될 익은 토마토의 좌표값을 `queue` 에 삽입합니다. 이후 `BFS` 를 통해 탐색을 진행합니다. 현재 위치를 `queue` 에서 빼내고 그 위치에서 갈 수 있는 상하좌우 좌표값을 구한 뒤 해당 좌표가 0이라면 동일한 좌표의 거리배열에 현재 위치 거리배열 값에 1을 더합니다. 이 과정을 `queue` 에 더 이상 삽입되는 좌표값이 없을 때까지 반복하며 마지막에 더한 거리배열의 거리 누적값이 최소 일수가 됩니다. 단, 탐색이 완료된 후에도 창고에 0의 값을 갖는 곳이 있다면 -1을 반환합니다. 

```javascript
function solution (board) {
    let answer = Number.MIN_SAFE_INTEGER;
    let n = board.length; // 행 길이
    let m = board[0].length; // 열 길이
    let dx = [-1, 0, 1, 0];
    let dy = [0, 1, 0, -1];
    let dist = Array.from(Array(n), () => Array(m).fill(0));
    let queue = [];
    
    function BFS () {
        while (queue.length) {
            let cur = queue.shift();
            for (let j = 0; j < 4; j++) {
                let nx = cur[0] + dx[j];
                let ny = cur[1] + dy[j];
                if (nx >= 0 && nx < n && 
                    ny >= 0 && ny < m && 
                    board[nx][ny] === 0) {
                    board[nx][ny] = 1;
                    dist[nx][ny] = dist[cur[0]][cur[1]] + 1;
                    queue.push([nx, ny]);
                    answer = dist[nx][ny];
                }
            }
        }
    }
    // 익은 토마토의 좌표값 queue에 할당
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (board[i][j] === 1) {
                queue.push([i, j]);
            }
        }
    }
    BFS();
    // 다 익지 못했을 경우 -1 반환
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (board[i][j] === 0) return -1;
        }
    }
    return answer;
}
console.log(solution([[0, 0, -1, 0, 0, 0], 
                      [0, 0, 1, 0, -1, 0], 
                      [0, 0, -1, 0, 0, 0], 
                      [0, 0, 0, 0, -1, 1]])) // 4
```
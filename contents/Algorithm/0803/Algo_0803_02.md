---
date: '2021-08-03'
title: '[JS Algo] 경로 탐색 (인접리스트)'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 경로 탐색 (인접리스트)

<details>
<summary></summary>
<div markdown="1">       
방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 반환해야 합니다.
</div>
</details>

## A. 풀이
경로 탐색 수행은 메모리 절약을 위해 보통은 인접행렬보다는 인접리스트를 활용합니다. 빈 배열(인접리스트)에 `정점 갯수 + 1` 만큼의 할당합니다. 방문 여부를 체크하기 위한 배열을 초기화합니다. <br>
주어진 방향그래프를 인접리스트 삽입합니다. 예를 들어, `[1, 2]` 라면 인접리스트 `1`번째 배열에 `2` 를 삽입합니다. <br>
`graph[v]` 의 `v`는 `v` 정점에서 갈 수 있는 값들을 가지고 있습니다. 방문여부를 체크해 이 값들을 하나씩 경로 변수에 추가, 삭제를 반복하며 종착지점에 도달할 때까지 재귀를 반복해 탐색을 수행합니다.

```javascript
function solution (n, edges) {
    let answer = 0;
    let graph = Array.from(Array(n+1), () => Array()); // 빈 인접배열(리스트) 초기화
    let check = Array.from({length: n+1}, () => 0); // 사용여부 체크 배열 초기화
    
    for (let [a, b] of edges) {  // 주어진 방향그래프 삽입
        graph[a].push(b);
    }
    console.log(graph);
    
    let path = [];
    function DFS (v) {
        if (v === n) { // v 가 종착지점에 도착
            answer++;
            console.log(path);
        } else {
            for (let nv of (graph[v])) { // v 정점에서 갈 수 있는 값들이 있고 그것을 하나씩 조회
                if(check[nv] === 0) {
                    check[nv] = 1;
                    path.push(nv);
                    DFS(nv);
                    check[nv] = 0;
                    path.pop();
                }
            }
        }
    }
    check[1] = 1;
    path.push(1);
    DFS(1);
    return answer;
}
console.log(solution(5, [[1, 2], [1, 3], [1, 4], [2, 1], 
                         [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]] )) // 6
```
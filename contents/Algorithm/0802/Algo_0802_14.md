---
date: '2021-08-03'
title: '[JS Algo] 송아지 찾기 (BFS)'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 송아지 찾기 (BFS)

<details>
<summary></summary>
<div markdown="1">       
잃어버린 송아지의 위치가 e로 주어집니다. A 는 현재 위치 s에서 송아지의 위치까지 이동합니다. 한 번의 이동시 앞으로 1, 또는 뒤로 1, 또는 앞으로 5를 이동할 수 있습니다. 최소 몇 번의 이동으로 A가 송아지의 위치까지 갈 수 있는지를 반환해야 합니다.
</div>
</details>

## A. 풀이
방문한 위치를 체크하기 위한 배열을 생성합니다. `while` 문을 반복할 때마다 `queue` 의 길이는 현재 레벨에 있는 노드들과 연결된 다음 레벨 노드의 갯수입니다. 그리고 해당 레벨의 노드 갯수만큼 `queue` 에서 노드 번호를 빼내고 (get) 해당 노드와 다음 레벨 노드를 추가하는 과정을 반복합니다. `queue` 에서 특정 레벨에 있는 노드들을 빼내고 빼낸 노드의 다음 노드를 추가하는 과정을 한 번 반복하면 `L` 변수를 통해 레벨을 증가시킵니다. 우리가 찾아야 하는 것은 송아지의 위치까지 몇 레벨을 거쳐 이동하는지입니다.<br>
현재 위치가 `5` 라면 우리가 다음 레벨에 갈 수 있는 좌표는 `4, 6, 10` 입니다. 각 좌표마다 이 과정을 반복하게 되는데, 연결되어 있는 노드들끼리는 이전에 방문한 노드는 제외하고 방문해야합니다. 이를 체크하기 위한 배열을 생성해 방문여부를 확인합니다. 반복문이 도는 횟수를 조금이라도 줄이기 위해 다음 레벨을 파악하는 과정에서 우리가 찾는 좌표가 발견된다면 `현재레벨 + 1` 을 반환합니다. 

```javascript
function solution (s, e){
    let answer = 0;

    function BFS () {
        let check = Array.from({length: 10001}, () => 0);
        let queue = [];
        queue.push(s);
        check[s] = 1;
        let L = 0; // 레벨 변수
        
        while(queue.length){
            let len = queue.length;
            // 레벨의 노드 갯수만큼 도는 for문
            for(let i = 0; i < len; i++) {
                // 위의 for문이 한 번 돌면 queue에는 해당 레벨의 노드들은 없어짐. 
                let x = queue.shift(); 
                // 현재 레벨의 다음 레벨 자식 노드들 확인하는 for문
                for (let nextX of [x-1, x+1, x+5]) {
                    if (nextX === e) return L + 1;
                    if (nextX > 0 && nextX <= 10000 && check[nextX] === 0) {
                        check[nextX] = 1;
                        queue.push(nextX);
                    }
                }
            }
            L++;
        }
    }
    answer = BFS();
    return answer;
}
console.log(solution(5, 14)); // 3
console.log(solution(8, 3)); // 5
```
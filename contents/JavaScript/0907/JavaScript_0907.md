---
date: '2021-09-08'
title: '2. JavaScript TIL'
categories: ['JavaScript']
summary: ''
thumbnail: './JS.png'
---

<!-- ![](./images/.PNG) -->

## 첫 번째 시간

- 용어를 안다는 것은 개념을 안다는 것. 용어를 잘 알아야 대화가 이뤄질 수 있다. 그리고 어떤 용어를 이해하기 위해서는 연계된 지식을 알 필요가 있다.
- 어떤 개념에 대해 낯설다는 것은 용어에 대해 잘 알지 못하기 때문에 발생하는데, 지레 겁먹고 어려운 것이라고 판단해서 더 조사하지 않는 경우 제대로 된 이해를 하지 못하게 되기때문에 공부 기반이 흔들릴 수 있다.

<발표시간>
<정리 필요>

- 예전 컴퓨터는 단일 목적으로 만들어졌을 것. 시간이 지나면서 범용적으로 사용하게 되면서 다양한 데이터를 사용하기 위해 메모리 관리 측면에서 메모리의 단위를 고착화하게 됐을것.
- ASCII : 숫자를 가지고 문자를 표현하는 인코딩 방식. 예를 들어 65를 숫자로 표현하면 65이지만 문자로 표현할 때는 A라는 약속을 하는 것. 아스키코드의 최소 단위가 7비트로 고착화 되는 과정을 거쳤을 것.
- 이후에 미국권이 아닌 전세계적으로 컴퓨터를 사용하게 되면서 유니코드까지 확장.
- ??패리티 비트 : 토끼굴.

- CS 지식을 어느정도 공부해야 할까? 나중에 점점 더 어려운 일을 하게 될수록 시간이 지나도 잘 변하지 않는 지식이 필요하게 될 것. 그것이 CS 전공자들이 배우는 내용. 지금 당장은 할 필요는 없으나 지속적으로 관심을 가지고 조금씩이라도 공부해야 함. 빠르게 공부해서 끝낸다는 개념은 아님.

- ??타입변환 방식에 따른 부수효과 차이가 있는가? 콘솔에 찍어보면 된다. 차이 없다.
- 데이터 타입마다 사용 목적이 있을텐데, 왜 타입을 변경하려 하는걸까? 그 목적에 맞게 변환해서 사용하기 위해서다.
- 개발자가 의도를 가지고 썼으면 명시적. 암묵적인 방식 중 아래와 같이

```js
var n = 100;
n + '';
```

와 같은 방식도 암묵적 방식이지만 개발자가 의도를 가지고 썼다면 가독성 측면에서 더 권장되는 방식이다.

<hr>

## 두 번째 시간

- 변수 선언은 컴파일 타임이 아니다. 인터프리팅 단계로 볼 수 있고, 인터프리팅도 두 단계로 나눌 수 있다. 한 줄 한 줄 실행되는 런타임 전에 따로 진행되는 과정이 있고, 변수 선언은 여기에 해당한다고 볼 수 있다. 코드를 실행하기 위해 평가하는 준비과정. 실행 컨텍스트 과정. 나중에 배울 것.

- 신입사원으로서 네카라쿠배에 가는 것이 좋다. 성장의 기회가 좀 더 폭 넓게 보장되고, 바로 일에 투입시켜서 성과를 요구하는 것보다 교육시켜서 키워가려는 의도가 더 크다. 이 외에 회사는 바로 일에 투입시켜서 성과를 내기를 원하는 것도 있고, 키워서 성장시키면 바로 더 큰 회사로 가려하기 때문에 경력을 좀 더 선호한다.

- 리터럴은 값이 되기 전의 텍스트. 평가라는 과정을 거쳐서 메모리에 안착을 해야 값이 되는 것. 그런데 리터럴은 값과 동치다. 미리에 평가라는 과정을 거쳐 값이 되기 때문. 따라서 리터럴을 값이라고 부를 수 있다. 더 나아가면 리터럴은 표현식이라고 볼 수 있다.
- 위의 문장으로 미루어 볼 때, 평가는 값을 만들어 내는 과정(Process)이다.
- 컴퓨터와 개발자간의 표기법에 대한 약속을 알고 있는 것은 JS 엔진에 있는 Parser 이고 이 약속에 맞게 어떤 작업을 실행하는 것이 구문분석, Parsing이다. 이 Parsing 평가라는 과정 중 하나라고 볼 수 있다. 평가도 실행의 범주에 들어 있다.

- 아래의 코드는 평가라기보다는 실행이라고 하는 것이 적절하다. 값을 만들어 내지 않기 때문에 아래는 표현식이 아닌 문이다.

```js
var a;
```

- 삼항 연산자는 표현식인 문. 값을 생성하므로. 가독성 측면에서 if 조건문보다 좋으므로, 삼항 조건 연산자로 해결이 가능하다면 삼항 연산자를 우선으로 쓰는 것이 좋다.
- CS에서는 '부수효과'라는 것은 좋지 않은 현상이다. 변수의 값을 변환시키기 때문.

<hr>

## 세 번째 시간

**완료값**

- 표현식이 아닌 문을 실행하면 완료값이라는 것을 만들어라 라고 ECMAScript 표준사양에 명시되어 있다. `undefined`는 평가 결과가 아니다.
- 개발자 도구의 콘솔에서 `>` 는 자동적으로 평가과정을 거쳐 값을 생성한다.
- `console.log()` 는 비표준이다. 표준사앙에 없다. 다만 브라우저와 node.js에서 둘 다 사용가능한 비표준이다. 따라서 출력되는 내용이 다를 수 있다. 브라우저가 좀 더 많은 정보를 줄 가능성이 있다.

- 책 목차에 대한 설명 유튜브 링크 올려주실 것.

**데이터타입**

- 자바스크립트의 데이터타입 갯수는 다른 언어에 비해 적은편. 그렇기 때문에 메모리 낭비가 있을 수 있다. 숫자를 표현할 때 부동소수점 형식을 따르고 8byte를 사용한다. 1 이라는 숫자 하나도 8byte를 차지한다. 7byte는 손해.

- 실수를 컴퓨터가 이해할 수 있도록 이진수로 변환할 때에 무한 소수가 되는 경우가 있다. 정수는 그렇지 않다.
- 자바스크립트는 모든 숫자를 실수로 인식한다. 그래서 아래 코드도 결과도출 가능

```js
1 + 1.0; // 1을 1.0으로 인식
// 2
```

- 적은 수를 표현할 때 큰 메모리를 차지할 필요가 없으므로 다른 언어는 숫자를 정수, 실수 등으로 좀 더 세부적으로 구분한다. 자바스크립트는 태생적으로 비개발자를 고려한 언어이므로 이렇게 세부적인 구분으로 메모리 효율성 관리를 사용자가 하지 않고 엔진이 자동적으로 관리.

- 문자열도 위와 같은 관점에서 배열형태가 아니라 하나의 문자열이라는 형태로 보고 iterable 이라는 특성을 줬다. 문자열은 원시값인데 `.`을 뒤에 붙이는 순간 자바스크립트 엔진은 암묵적으로 문자열을 객체라고 인식한다. 이런것을 레퍼객체라고 한다.

- 좋은코드에 대한 구분이 있어야 구현 이상의 플러스 알파를 어필할 수 있다. 좋은코드라는 기준에는 여러가지 요소가 있을 수 있다. 백틱은 가독성 측면에서 좋은 코드라 보여진다. 다만 백틱은 따옴표들과 다르게 개행이 있냐 없냐 등의 추가적인 검증이 들어가기 때문에 아주 미세한 효율성의 차이가 발생할 수 있다.

- 프론트엔드는 결과물이 HTML이기 때문에 HTML 코드를 JS에서 쓰는 경우가 많이 있다. 따라서 개행이 필요한 경우가 있기 때문에 백틱 사용빈도가 어느정도 있다고 보여진다.

<hr>

## 네 번째 시간

- null의 경우 초기화할 때 타입을 사전에 알지 못하는 경우 명시적으로 값이 없다, 모르겠다는 의도를 가지고 사용할 수 있다.
- 또한 null은 함수를 만들 때도 어떤 조건에 맞지 않아서 원하는 값을 리턴하지 못하게 되는 경우, 에러를 발생시키는 것보다 실행은 되지만 값은 없다(의도적 부재)라는 것을 다른 개발자에게 알리기 위해서 사용한다.

- 네이밍 컨벤션에서 일반적이다라는 의미는 자바스크립트 사양에서 제공되는 컨벤션을 기준으로 하는 의미다.

- 객체에서 프로퍼티는 키와 밸류를 가지는데 키는 문자열이다. 따라서 나중에 쓴 키와 기존 키의 문자열이 중복될 경우 나중에 쓴 것으로 오버라이드 된다. 이러한 경우를 방지하기 위해 Symbol type으로 키를 생성해서 중복을 방지하는 방법이 있다. 심벌 타입을 사용하는 이유.

- a는 선두 메모리 어드레스와 해당 어드레스에 있는 값의 타입정보를 가지고 있다. 따라서 사실상 변수 a가 타입을 가진다고 말할 수 있다. undefined라는.

```js
var a;
```

- 같은 변수에 타입이 다른 값을 할당함에 따라 변수의 타입이 변경되는 것을 동적 타입 언어라고 한다. 즉, 변수의 선언이 아닌 할당에 따라 타입이 결정(타입 추론) 되는 것을 말한다. 정적 타입의 언어는 타입을 정해놓으면 다른 타입의 값을 할당할 수 없다.

- 동적 타입 언어 특성상 변수를 너무 많이 쓰면 에러 발생 가능성이 높아진다. 변수는 적절한 갯수를 사용해야 하고, 초기화를 통해 변수 타입을 사전에 결정하고 이후에 재할당은 지양하는 방향으로 코드를 짜야 한다.
- 필요하다면 새로운 변수를 만드는 것이 좋고, 만들더라도 함수 스코프 내에서 필요한 로컬 변수로 생성해서 변수의 생명 주기를 짧게 가져가는 것이 좋다. 함수 내에서도 변수의 생성은 한 두줄 정도 짧게 가져가는 게 좋고, 여러 줄로 만들면 확인하기 어렵다. 혹은 const를 사용한다. const는 재할당이 금지된 변수다.
- 결국 근본적으로 실수가 발생하지 않게하는 노력을 해야한다는 맥락이다.
- 이러한 측면에서 동적인 부분을 제어해주는 언어가 TypeScript다. 타입을 사전에 정의함으로써 에러, 실수 발생 등을 줄이기 위한 목적.
- 라이브러리를 쓰면 왜 쓰는지 알고 써야 한다.

- 나중에 let, const를 배워서 var보다 이것들을 사용을 하게 될 경우 const를 우선시 해야하고 부득이하게 재할당을 해야할 경우 let을 사용하는 방향으로 가야한다.

- 나중에 코드리뷰 할 때 변수명, 함수명을 의미없게 짓는 것은 태도, 성의의 문제라고 보여진다. 처음 생성할 때 고민해서 생성하는 것이 좋다.
- 변수명은 명사로, 함수명은 동사로. 함수 반환값이 true, false를 반환하는 경우 is, 또는 has를 사용한다. is는 조건문이 맞니? has는 조건문에 해당하는 값이 있니?
- 변수명을 지을 때도 굳이 줄여서 할 필요가 없다면 약어로 네이밍 하지 않는 것이 좋다. 효율의 문제를 따질 수 있는데 배포할 때 어글리파이를 통해 변수명을 간단하게 바꾸기 때문에작은 효율의 문제는 무의미해진다. 오히려 가독성 측면을 중요시하는게 낫다.

<hr>

## 다섯 번째 시간

- ++, -- 는 안티패턴이다. 전위, 후위 사용에 따라 결과가 달라지고 암묵적 재할당을 통한 부수효과가 있기 때문에 코드의 결과를 변화시키기 때문. 가독성 측면에서 명시적인 재할당 방법을 사용하는 것이 좋다. +=, -=와 같이.
- for문을 알고리즘 풀때 쓰는것. 성능의 문제로. 나중에 더 배울것.
- delete 연산자도 안티패턴. 프로퍼티 제거용인데, 프로퍼티를 명시적으로 제거할거라면 왜 만들었나부터 생각해봐야 할 문제다. 그런 관점에서 안티패턴이다.

- isNaN()만 쓰는것보다 Number.isNaN() 쓰는것을 권장.

- 지수 연산자는 함수와 달리 사용법만 알면 크게 가독성을 헤치지 않고 편리하게 사용할 수 있다. 반면에 Math.pow() 함수를 사용할 경우 함수의 인수를 줘야하므로 사용하기 위해 추가적인 정보를 알아야 한다. 순서와 어떤 인수로 줘야하는지 등에 대한 정보들. 따라서 연산자와 함수 두 가지 방법이 있다면 연산자 사용을 권장한다.

- 변수 선언은 자바스크립트 엔진에 식별자의 존재를 알리는 것. 따라서 아래 코드의 연산 순서는 a가 첫 번째, 연산자 우항의 피연산자 1이 두번째, 마지막은 이 두 가지를 가지고 어떤 연산을 하는지를 결정하는 = 을 할당.

```js
a = 1;
```

- 예습 범위는 10 ~ 12장 함수까지

---
date: '2021-10-06'
title: '13. JavaScript TIL'
categories: ['JavaScript']
summary: ''
thumbnail: './JS.png'
---

<!-- ![](./images/.PNG) -->

## 첫 번째 시간

- DOMConentLoaded 이벤트 타입의 경우 'on' prefix를 붙여서 이벤트 핸들러 등록이 불가능하다. 그래서 이럴 때는 addEventListener 방식을 사용한다.

- 어떤 큰 자바스크립트가 있다면 번들링할 때 큰 기능으로 구분해서 나눠서 번들하고, 실행 시점을 필요할 때 실행하게 하도록 자바스크립트로 다이내믹하게 조절할 수 있다.

<hr>

## 두 번째 시간

- 개발자도구 엘리먼트의 프로퍼티탭에서 요소 노드의 상속관계를 알 수 있는 프로토타입들을 확인할 수 있다.
- getElements~ 는 지양. 차라리 getElement~. 그것보다는 querySelector 메서드 사용 권장

<hr>

## 세 번째 시간

- innerHTML 은 사용자의 입력(Untrusted data)을 자바스크립트 코드로 받아올 수도 있어 XSS 공격에 취약하다는 문제가 있다. 네이버 과제에서도 명시적으로 쓰지 말라고 언급함.

- 이벤트 타입에 따라서 이벤트 객체의 프로퍼티 내용이 달라진다. 따라서 이렇게 타입을 구분해 놓은것.

- onkeyup 이벤트 발생 후 생성된 이벤트 객체를 참조할 때, 어떤 키보드 버튼이 눌렸다가 떼어졌는지 참조하기 위해서는 이벤트 객체의 key 프로퍼티를 사용하는 것을 권장한다.

- input text 요소에서 발생하는 이벤트는 keyboard 타입 이벤트로 확인하고, checkbox와 같은 input은 값 변경 이벤트 타입의 change로 확인한다.

- 체크박스에 따른 스타일 변경같은 경우 굳이 자바스크립트로 동적으로 조작할 필요없이 CSS로 가능하다면 CSS로 하는 것이 좋다.

- 클릭 이벤트는 모든 요소가 발생시킬 수 있다.
- classList.contains('classname') : 여기서는 마침표를 사용하지 않는다.

<hr>

## 네 번째 시간

- 이벤트를 위임하면 이벤트 핸들러 안에서 한 번 걸러주는 작업이 (반드시는 아니지만) 필요한 경우가 대부분이다.

- 애플리케이션은 서버가 DB를 가지고 있어서 웹사이트에 대한 초기, 또는 변경된 값들을 가지고 있어야 한다. 예를 들어, Todo app이라고 하면 서버 DB에 todos 배열이 존재하고, 할 일을 완료해서 체크박스를 체크했다면 변경된 내용에 대해 서버에서도 todos 배열의 completed 값을 true로 변경된 값을 가지고 있어야 한다. 이를 통해 다시 렌더링 해준다.
- 할일 목록 자체를 버튼을 통해 삭제한다면
- 뷰가 바뀌면 서버의 todos 배열이 바뀐다. 서버의 todos 배열이 바뀌면 뷰도 다시 렌더링해서 바뀐다. 배열이 바뀌어서 뷰를 바꾸기 위해 렌더링 하는 함수를 만들어야 한다. 즉, 상태(state)가 변하면 뷰가 변하는 것.
- 그러한 상태는 직접적으로 mutate하는 함수를 만들지 않는다. 상태는 불변성을 유지해야 하는 것을 원칙으로 한다.

<hr>

## 다섯 번째 시간

- className 대신에 classList를 쓰는 이유? className은 공백으로 구분된 클래스 네임 전체를 가져오게 되므로 추가적인 변환을 통해 원하는 클래스만 뽑아내서 메서드의 인수로 사용해야 한다.
-

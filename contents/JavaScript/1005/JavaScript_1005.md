---
date: '2021-10-05'
title: '13. JavaScript TIL'
categories: ['JavaScript']
summary: ''
thumbnail: './JS.png'
---

<!-- ![](./images/.PNG) -->

## 첫 번째 시간

**DOM 컬렉션 객체**
DOM 쿼리로 결과를 가져올 때, 여러 개의 결과를 가져올 경우 DOM 컬렉션 객체로 가져오게 된다. 유사배열 객체이면서 이터러블인 `HTMLCollection`과 `NodeList`가 있다. 가져올 컬렉션 객체는 배열로 변환해서 유용한 배열 고차 함수를 사용하는 것이 for문을 사용하는 것보다 좋다.

**38장 브라우저 렌더링**

- 결국 렌더링을 위해 우리가 만드는 것은 HTML 문서다. CSS와 JavaScript는 그러한 HTML 문서를 조작하는 일이다. HTML이 없으면 무용지물이다.
- 그러면 HTML을 실행시키는 것은 무엇일까? 브라우저다. 따라서 브라우저의 동작을 잘 이해해야 좋은 자바스크립트 코드를 짤 수 있따.

- 과거에는 View를 HTML, CSS, JavaScript를 파일로 구분해서 작업을 했다. 그러나 CBD(Coponent Based Dev.)를 추구하면서 파일을 구분하지 않는다. View를 구성하는 하나의 컴포넌트로 보기 때문이다.

- HTML의 시멘틱한 태그는 컨텐트에 있는 텍스트를 보조하는 메타 정보를 나타내준다. 태그별로 다른 스타일은 브라우저에서 제공하는 유저 에이전트 스타일이다. HTML은 스타일을 제공하지 않는다고 보는 것이 맞다.

- 여기서 렌더링이라고 하는 것은 페인트 과정을 통해 화면에 보여지는 것까지를 의미한다. 서버 사이드 렌더링에서는 HTML 문서를 만드는 것까지(?)를 의미한다. 프레임워크(React)에서는 또 다르다.

- 브라우저 렌더링 과정에서 주의해야 할 부분은 리플로우다. 성능과 직결되기 때문.

  - 자바스크립트에 의한 노드 추가 또는 삭제
  - 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
  - HTML 요소의 레이아웃에 변경을 발생시키는 css 프로퍼티 값 변경

- 정적 리소스 : HTML, CSS, JavaScript, 이미지, 폰트 등의 리소스. 클라이언트가 서버에 리퀘스트하는 것은 주로 이러한 리소스들.
- 클라이언트는 브라우저로 통칭되고 주소창을 통해 서버에 리소스를 요청한다.
- IP 주소는 모든 컴퓨터에 1:1 매칭되어 있다고 생각하자. 우리가 주소창에 입력하는 호스트는 DNS를 통해 IP주소로 변환되고, 그 IP 주소를 갖는 서버에게 요청을 전송하는 것이다. 서버는 루트폴더로 찾아간다. 만약 주소창에 호스트 외에 추가적인 정보(path)가 있다면, 서버는 해당 path를 통해 내부 폴더로 찾아가 리소스를 검색한다.
- 클라이언트가 요청한 리소스가 없다면 404 에러를 응답한다.
- 기본적으로 HTTP 프로토콜(주소창)은 아스키코드로만 주고 받는다. 다국어를 쓸 때는 아스키 코드를 유니코드처럼 사용한다.

- HTML 파일을 이러한 요청과 응답에 지속적으로 주고받는 것은 비효율적. 따라서 객체 형태인 템플릿으로 주고받는 것이 지속적인 요청과 응답 리소스에 대한 비용을 줄일 수 있다(?)

- 클라이언트가 서버에 무언가 요청을 할 때, HTTP 프로토콜 규약에 따라 header, body 등으로 구분되고 이 중에서도 header 부분에 무엇을 요청했고 응답했는지가 표시되어 전달된다.

- 리소스에 대해 하나의 서버에서 모두 응답하는 것이 아니라 이미지 서버 등으로 따로 구분되어 응답한다. 개발자 도구의 네트워크 탭에서 요청해서 받은 리소스에 따라 프로토콜 탭에 HTTP 버전이 나눠진 것으로 서버가 다름을 확인할 수 있다.

- HTTP 프로토콜의 body에 담아서 요청을 주고 받는 것이 POST 방식. GET 방식은 주소창의 URI에 query string에 포함시켜서 주고 받는 것.
- HTTPS는 이러한 요청과 응답을 암호화해서 주고받기 때문에 GET방식도 암호화된다.

<hr>

## 두 번째 시간

- https://poiemaweb.com 까지만 Scheme과 Host만 요청한 것을 루트 요청이라고 하고, 암묵적으로 https://poiemaweb.com/index.html을 붙여서 요청이 전송된다.

- 요청한 리소스는 packet이라고 하는 단위로 쪼개서 응답받는다.

- API (Application Program Interface) : 애플리케이션과 애플리케이션 사용자와의 중간 다리 연결을 하는 프로그램(?)

- 스크롤은 리플로우를 발생시키기 때문에 관련 함수들이 있다면 쓰로틀링 등의 작업을 하지 않으면 성능 저하에 치명적인 영향을 미칠 수 있다. (그러면 정적 페이지도 그런가? 인피니티 스크롤 페이지는 어떤 처리가 되어있나?)

- 레이아웃 발생 유발 요소 치팅 시트

  - https://devhints.io/layout-thrashing
  - https://gist.github.com/paulirish/5d52fb081b3570c81e3a
  - https://kellegous.com/j/2013/01/26/layout-performance/
  - https://csstriggers.com/ (브라우저마다 발생 요소가 다르다.)

- 위치에 대한 정보를 가져오는 것만으로도 리플로우가 발생한다. 항상 그 위치를 기억하고 있는 것이 아니므로.
- DOM 생성이 완료된 직후에 `DOMContentLoaded` 이벤트가 발생한다. `defer`는 자바스크립트를 이때 실행한다. 닫는 body 태그 바로 앞에 쓰는 것과 실행 시점이 같다.

<hr>

## 세 번째 시간

**39장 DOM**

- 실무에서 DOM API를 안 쓰는 이유? 단순히 디자인이 바뀌거나 태그를 변경했을 때, DOM API를 사용한 자바스크립트 코드도 같이 변경되어야 한다. 이게 큰 문제다. 자바스크립트 코드가 HTML에 큰 의존성을 가지고 있다. 리액트는 그 반대의 의존성을 가지게 된다. HTML을 문자열로 가지고 있으면 된다.
- 정해진 템플릿 형태의 HTML 문자열을 가져다가 자바스크립트 코드로 조작하는 것이 템플릿 엔진의 역할
- 앵귤러는 템플릿 엔진 베이스다. 리액트는 템플릿 엔진을 쓰지 않는다. 온전한 자바스크립트 객체로 돌려주는 것(?)
- HTML이 하나 존재해서 프레임워크의 자바스크립트 코드로 조작해 HTML에 대한 자바스크립트의 의존성을 낮추는 것이 SPA. 그러나 SPA는 SEO에 약하다. 이럴 때 서버사이드 렌더링을 고려해 볼 수 있다.

<hr>

## 네 번째 시간

<hr>

## 다섯 번째 시간

---
date: '2021-09-23'
title: '8. JavaScript TIL'
categories: ['JavaScript']
summary: ''
thumbnail: './JS.png'
---

<!-- ![](./images/.PNG) -->

## 첫 번째 시간

<hr>

## 두 번째 시간

**코드리뷰**

- 코멘트 쓸 때,
- 조건문 쓸 때는 중첩으로 하지 않는 것을 철칙으로 하는 것이 좋다.
- 함수 객체는 copy를 할 수 없다. JSON.Stringify를 써도 안됨.
- 함수만 가지고 있는 내부슬롯들이 많기 때문. 프로토타입의 체인도 동일하게 가져와야 함.
- 이럴 때는 라이브러리를 쓰는게 유용하다.
- 함수명에 'is' prefix가 붙으면 반환값은 불리언이라는 말이다.
- 'isNot' 과 같인 부정 prefix는 조금 이해하는데 어려울 수 있다.
- forEach 의 콜백함수에서 return을 한다는 것은 고차함수에게 하는것. 근데 그게 undefined다. 그래서 콜백의 리턴이 필요한 경우라면 for..of 와 같은 반복문을 사용하는게 낫다.

- deepClone 함수 new.obj.constructor() 로 새로운 빈 객체를 생성하는 방식이 조금 다르다.

<hr>

## 세 번째 시간

**20장 strict mode**

- 클래스 내부, 모듈의 내부 코드는 기본으로 strict mode다. 굳이 지정할 필요가 없다.
- ESLint를 사용하자.
- strict mode 에서의 this 는 알고갈 필요가 있다.

**21장 빌트인 객체**

- 호스트 객체의 Node.js 호스트 객체들은 file을 조작할 수 있지만, 브라우저 환경 호스트 객체들은 file을 조작할 수 없다. DOM을 조작할 수 있다.

**전역객체**

- 실행컨텍스트 관련지어 내용 이해 필요!
- 불리언도 래퍼 객체가 있지만 사실상 true 와 같은 것을 접근해서 사용할 일이 거의 없기 때문에 의미가 없어서 잘 사용하지 않는다고 보면 된다.
- 전역 객체 안에 있는 프로퍼티들은 전부 전역에 선언된 식별자라고 볼 수 있다.
- 전역 객체는 브라우저의 탭마다 가지고 있다. 탭끼리 공유되는게 아니다.
- 전역 객체는 가비지 컬렉션의 예외에 해당한다.
- 렉시컬 환경들은 링크드 리스트. 링크드 리스트의 요소들이 환경 레코드를 가지고 있다. 한 몸으로 봐도 됨.
- ES5 시절의 window 객체는 전역 스코프의 역할을 했다. 따라서 var 로 선언하면 전역 객체의 프로퍼티로 들어간다. 식별자인척 해서 window.something이 아닌 something으로 바로 접근할 수 있게끔 만들었다.
- let, const로 선언하면 전역 객체의 스코프로 들어가지 않고, 또다른 환경의 전역 환경에 들어가는데 그것을 선언적 환경이라고 한다. 따라서 이것들은 winodw.somthing으로 하면 접근할 수 없다.
- parseInt, parseFloat 기억.
- parseInt는 진법 변환시 많이 쓴다. 문자열을 숫자인 정수로 변환할 때 사용함.
- 여기의 메서드들은 있다라는 것과 어떤 기능을 하는지를 숙지하는 것이 중요. 그래서 필요할 때 찾아서 쓸 수 있도록.
- eval은 좀 특별해서 기억할 필요가 있다. 사용을 지양하는 목적으로. 너무 깊게 왜 안써야되는지를 파고들 필요는 없다.
- encodeURI / decodeURI 는 나중에 많이 쓰게 될 것. HTTP를 공부할 시점.
- URI의 com까지는 서버(Host)에 대한 식별자.
- URI는 전기신호로 랜선을 타고 다님. 그러기 위해서는 ASCII 코드로 바꿔서 다녀야 함. 한글은 ASCII코드에 없다. 따라서 ASCII코드에 없는 것들은 유니코드와 비슷하게 바꾸는 것을 인코딩한다고 한다. 서버에 이러한 인코딩된 코드가 가면 서버는 이것을 해석하기 위해 디코딩을 한다.
- 통신이 어떻게 이루어지는지에 대한 방식에 대한 이해가 필요하다.
- https, http는 서버와 서버간의 통신이 어떻게 이루어져야 하는지에 대한 규약.
- 그림으로 된 HTTP 얇은 책 한 번 읽어보는 것 추천.
-

<hr>

## 네 번째 시간

**22장 this**

- call, apply 는 세트로 이해해야 함. Function.prototype의 메서드. 따라서 `.` 앞에는 함수객체가 와야한다. this를 교체하면서 호출한다. 첫 번째는 인수는 this를 바인딩 할 객체가 와야한다. call는 단일로 전달, apply는 배열로 뭉쳐서 전달.
- `Array.prototype.slice.call(arrLike);`, `[].slice.call(arrLike);` 예전에는 이렇게 배열을 복사했다.

**중요**

- bind는 this만 교체한다. 콜백함수에 명시적으로 this를 바인딩할 때 사용.
- 모던한 방법은 화살표를 사용하는 것. 화살표 함수는 this가 없다. 따라서 자연스럽게 함수의 상위 스코프로 가서 this를 바인딩한다. 외부함수의 this와 콜백함수의 this 불일치 문제를 해결할 수 있다.

- 클래스에서의 this, DOM, event handler 에서의 this 문제가 있다. 가장 좋은 것은 this 사용을 지양하는 것.

**예습관련**

- 23장, 24장은 세트. 이 두 챕터 다시 정독.

<hr>

## 다섯 번째 시간

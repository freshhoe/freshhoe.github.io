---
date: '2021-09-24'
title: '9. JavaScript TIL'
categories: ['JavaScript']
summary: ''
thumbnail: './JS.png'
---

<!-- ![](./images/.PNG) -->

## 첫 번째 시간

- YAGNI : 프로그래머가 필요하다고 간주할 때까지 기능을 추가하지 않는 것이 좋다는 것. 오버엔지니어링을 지양하는 것.

<hr>

## 두 번째 시간

**23장 실행 컨텍스트**

- 소스코드가 평가되면 실행컨텍스트가 만들어진다. 그런데 모든 코드가 아닌 소스코드의 네 가지 타입에 해당하는 코드만 만들어진다. 전역, 함수, eval, 모듈 코드.
- 함수코드 내부란 몸체(코드블록 안)를 말하는 것. 호출 후에 내부 코드가 실행되는 것.
- 다른 언어에서는 실행 컨텍스트를 심볼 테이블이라고 부르기도 한다.
- 참조 및 할당 등의 소스코드 실행을 위한 평가단계에서 선언문에 의해 생성할 식별자들이 실행 컨텍스트에 등록된다.
- 평가단계에서 변수에 undefined 이 할당되는 것은 초기화라고 부르기 어렵다. 자바스크립트 엔진에 의해 암묵적으로 초기화가 강제되는 것이므로. 따라서 처음 변수에 값을 할당하는 것을 초기화라 부르는 것이 옳다.
- 현재 실행중인 실행 컨텍스트라는 것은 참조할 것은 어디서 참조해야 할지, 실행할 코드는 어디서 실행해야할지에 대한 기준이 된다.
- AST(Abstractive Syntax Tree) 추상 구문 트리를 만들어서 선언문을 먼저 뽑아 평가 단계에서 실행된다. AST 상에 `const x = 1;` 는 두 개로 구분되어 있다. 선언과 할당으로.
- const, let으로 선언된 변수들의 평가단계에서의 초기화는 어떤 값으로 초기화 되는지 알 수 없다. 사양서에도 없다. 엔진마다 다를 수도.
- console 은 전역 실행 컨텍스트에 등록된 식별자이면서 객체다. 애플리케이션에서 하나만 존재하는 싱글톤 객체다.
- 바인딩 오브젝트는 Node, 브라우저 환경에 상관없이 전역 객체를 참조? 하기 위해 생성된 별도의 객체다.
- 함수의 매개변수는 함수 몸체의 var 키워드로 선언된 식별자다.

<hr>

## 세 번째 시간

- 이벤트가 발생했을 때 처리해야 될 함수는 브라우저가 감지하고 실행한다.
- 전역 객체는 전역 실행 컨텍스트가 사라져도 계속 존재한다. 이벤트에 대한 처리를 위해. 브라우저를 종료해야 사라진다.
- 왜 네 가지의 소스코드로 구분해놨을까? 실행 컨텍스트를 만드는 소스코드가 이 네 가지고, 그 종류에 따라 방식이 다르기 때문.
- 우리가 앞으로 이야기 할 스코프는 렉시컬 환경이다. 외부렉시컬환경참조가 스코프 체인을 형성하는 참조값을 가지고 있다.
- 실행컨텍스트가 없더라도 스코프, 즉 렉시컬 환경은 따로 만들 수 있다.
- 반복문에서 i를 let으로 초기화 하면 외부 변수지만 블록 레벨 스코프를 형성해 지역 변수로써 사용되는데, 소스코드 네 가지 타입에 속하지 않기 때문에 실행 컨텍스트를 생성하지는 않고, 렉시컬 환경만 따로 만들게 된다.
- 그런데 반복문이면 이러한 렉시컬 환경이 반복문 횟수 만큼 만들어지고 스코프 체인도 길어진다.

<hr>

## 네 번째 시간

**24장 클로저**

- 함수형 프로그래밍 언어라면 클로저를 전부 지원한다.
- 클로저는 자신의 스코프(렉시컬 환경)뿐만 아니라 상위 스코프에 대한 정보(`[[Environment]]`를 통해)도 가지고 있는 함수다! 이러한 정의에 기반했을 때, 자바스크립트의 함수는 모두 클로저다. 그러나 일반적으로 그렇게 부르지 않는다.
- 함수 객체가 상위 스코프에 대한 참조값으로 `[[Environment]]` 을 가지는 것은 생성될 때부터다. 즉, 생성될 때부터 상위스코프에 대한 정보를 가지고 렉시컬 환경의 체인, 즉 스코프 체인을 형성하게 된다.
- 함수가 객체가 아니라면 상위 스코프에 대한 정보를 내부 슬롯으로 가지고 있지 않을 것이다.
- (예제 24-06) 상위 스코프의 식별자를 하나도 참조하지 않으면 클로저라고 하지 않는다. 상위 스코프의 식별자를 날려버리기 때문. 기본적으로 외부함수와 내부함수가 있을때, 내부함수가 외부함수보다 오래 살아남고(생명주기가 더 길고), 내부 함수가 외부 함수의, 즉 상위 스코프의 식별자를 참조해야 클로저라고 부를 수 있다.
- 외부함수보다 더 오래 살아남기 위해서는 내부함수를 외부함수가 반환해야 한다.
- `debugger` 키워드를 코드 중간에 쓰면 해당 위치에서 실행이 멈춤. 개발자도구에서 해당 키워드를 통해 클로저를 구현한 코드를 실행하면 `Closure`라고 상위 스코프를 표시해주고 해당 스코프에서 클로저가 참조하는 식별자를 표시해준다.
- 클로저를 적극적으로 써야하는데, 그럼 어떤 상황에서 써야하는가?
- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 즉, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용.
- 2개 이상의 클로저를 반환할 경우 객체에 담아서 반환.

**예습 범위**

- 따로 없음. 이미 한 거 다시 보기. 월요일 수업은 27장 배열까지 들어갈 수도.
- 다음주 금요일에 위클리 테스트를 보는데 월요일 수업 나간거까지. 예상 범위 20 ~ 27장.

<hr>

## 다섯 번째 시간

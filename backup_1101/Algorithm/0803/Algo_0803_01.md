---
date: '2021-08-03'
title: '[JS Algo] 경로 탐색(인접행렬)'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 경로 탐색(인접행렬)

<details>
<summary></summary>
<div markdown="1">       
방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 반환해야 합니다.
</div>
</details>

## A. 풀이
정점의 연결 여부를 `0`, `1` 로 표시한 행렬(인접행렬)을 사용해 그래프 경로 탐색을 수행합니다. 그래프의 경로 탐색은 한 번 방문한 정점은 방문하면 안된다는 것을 기본으로 가정합니다. 따라서 방문여부를 체크하기 위한 배열을 초기화합니다.<br>
입력으로 주어진 방향그래프를 사용해 연결되어 있는 부분은 인접행렬의 값을 `1` 로 할당합니다. 경로를 할당하기 위한 배열을 만들고 해당 배열에서 정점의 값을 넣고 빼며 종착지점에 도달하기 위한 경로를 탐색합니다. 인접행렬에서 `1` 의 값을 갖고 있고, 이전에 방문한 적이 없는 곳만 경로에 추가하면서 `DFS` 를 사용해 종착지점에 도달할 때까지 재귀를 반복합니다.

```javascript
function solution (n, edges) {
    let answer = 0;
    let graph = Array.from(Array(n+1), () => Array(n+1).fill(0)); // 인접행렬 초기화
    let check = Array.from({length: n+1}, () => 0); // 사용여부 체크 배열 초기화
    
    for (let [a, b] of edges) {  // 주어진 방향그래프 삽입
        graph[a][b] = 1;
    }
    console.log(graph);
    let path = [];

    function DFS (v) {
        if (v === n) { // v 가 종착지점에 도착
            answer++;
            console.log(path);
        } else {
            for (let i = 1; i <= n; i++) {
                if (graph[v][i] === 1 && check[i] === 0) {
                    check[i] = 1;
                    path.push(i);
                    DFS(i);
                    check[i] = 0; // 하나의 뎁스를 모두 탐색하고 나왔다면 해당 노드는 사용여부 해제
                    path.pop();
                }
            }
        }
    }
    check[1] = 1;
    path.push(1);
    DFS(1);
    return answer;
}
console.log(solution(5, [[1, 2], [1, 3], [1, 4], [2, 1], 
                        [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]] )) // 6
```
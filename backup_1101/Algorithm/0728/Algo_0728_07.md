---
date: '2021-07-28'
title: '[JS Algo] 최소 매출'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 최소 매출
<details>
<summary></summary>
<div markdown="1">       
배열 N 중에서 연속된 k 길이의 부분배열 중 최소값을 구하는 문제입니다. 모든 부분 배열의 최소값을 원소로하는 하나의 배열을 반환해야 합니다.<br>
ex) N = 10, K = 3, [11,12,15,20,25,10,20,13,15,19] <br>
- [11,12,15] => 11 / [12, 15, 20] => 12 <br>
- answer: [11, 12, ...]

</div>
</details>


## A. 풀이
**deque** 을 이용합니다. **deque** 에는 [배열원소값, 인덱스] 로 구성된 배열을 삽입합니다. 인덱스 값을 이용해 **deque** 의 길이를 유지해야하기 때문입니다. **deque** 에서 `k` 길이의 부분 배열의 원소에 대한 대소비교가 이루어지고 최소값을 찾아 결과 배열에 추가합니다. <br>
처음 **k-1** 개의 원소와 그 이후의 원소는 **deque** 에 삽입 후 이루어지는 액션이 조금 다릅니다. 문제에서는 `k` 개의 부분 배열 중 최소값을 요구하고 있으므로 **deque** 의 길이도 `k` 를 넘지 않아야 합니다. 처음 **k-1** 개의 원소에 대해서 이 부분을 고려할 필요가 없기 때문에 이 조건과 관련된 필터링(조건문)을 추가할 필요가 없습니다. 주어진 배열에서 조회된 원소는 **deque** 에 삽입 전, **deque** 에 있는 원소들과 크기를 비교합니다.<br> 
**deque** 에 이미 삽입된 원소가 현재 조회되어 삽입예정인 원소값보다 크다면, 해당 원소는 최소값이 될 수 없으므로 **deque** 에서 제거합니다. 이 과정을 **deque** 에 삽입될 원소보다 큰 값이 없을 때까지 반복합니다. 이 과정을 통해 **deque** 은 항상 오름차순을 유지하게 됩니다. 해당 작업이 끝나면 **deque** 의 가장 앞 원소는 최소값이 되기 때문에 이 원소값을 결과 배열에 추가합니다.<br>
새로운 원소 조회 전, 현재 **deque** 의 길이가 `k` 라면 맨 앞에 있는 원소를 제거합니다. 이 과정을 반복해 각 부분배열의 최소값을 찾고 결과 배열에 추가해 반환합니다.

``` javascript
function solution (nums, k) {
    let answer = [];
    let deque = [];
    // 주어진 k - 1 바로 직전까지 먼저 삽입
    for (let i = 0; i < k - 1; i++) {
        // 덱의 원소 존재여부와 덱의 마지막 원소값이 현재 조회되고 있는 값보다 큰지 확인
        while (deque.length > 0 && deque[deque.length - 1][0] > nums[i]) {  
            deque.pop();
        }
        // 현재 조회되고 있는 값보다 큰 값이 없으면 인덱스와 함께 삽입
        deque.push([nums[i], i]); 
    }
    // k - 1 부터 삽입
    for(let i = k - 1; i < nums.length; i++) {
        while (deque.length > 0 && deque[deque.length - 1][0] > nums[i]) {
            deque.pop();
        }
        deque.push([nums[i], i]);
        answer.push(deque[0][0]);
        if (deque[0][1] === i-k+1) deque.shift();
    }
    return answer;
}
console.log(solution([11, 12, 15, 20, 25, 10, 20, 13, 15, 19], 3));
// [11, 12, 15, 10, 10, 10, 13, 13]
```

### 참고사항
문제에 입력변수에 대한 제한의 상한이 어떤 값이 주어졌냐에 따라 효율성(시간복잡도)을 고려해야 할 수도 있다. 

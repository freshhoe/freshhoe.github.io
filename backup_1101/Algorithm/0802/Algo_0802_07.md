---
date: '2021-08-02'
title: '[JS Algo] 중복순열 구하기'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 중복순열 구하기

<details>
<summary></summary>
<div markdown="1">       
1부터 N까지 번호가 적힌 구슬이 있습니다. 이중에서 중복을 허락하여 M번을 뽑아 일렬로 나열하는 방법을 모두 반환해야 합니다.
</div>
</details>

## A. 풀이
해당 문제는 `n` 의 갯수에 따라 상태트리 가지의 갯수도 달라지게 됩니다. 입력 예제가 `3`이라면 가지도 세 개씩 뻗어나가게 됩니다. 임시배열에 `n` 이하의 값을 원소로 `push`, `pop`을 반복하며 재귀함수를 이용해 부분집합을 찾아나갑니다. 재귀 중단 조건은 재귀의 인수가 `m`이 되었을 때입니다. `for` 문의 `i` 인덱스를 원소값으로 사용하기 때문에 재귀의 인수는 중단 레벨을 판단하기 위한 용도입니다. 중복을 허용하므로 같은 원소가 하나의 부분집합에 포함될 수 있습니다.


```javascript
function solution (n, m) {
    let answer = [];
    let tmp = [];

    function DFS (L) {
        if (L === m) {
            answer.push(tmp.slice());
        } else {
            for (let i = 1; i <= n; i++) {
                tmp.push(i);
                DFS(L + 1); // 레벨은 단순히 m 레벨에서 멈추게 하기 위한 용도
                tmp.pop();
            }
        } 
    }
    DFS(0);
    return answer;
}
console.log(solution(3, 2));
// [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]

// 중복 순열에 아래와 같이 체크 조건을 줘서 이미 추가한 것은 중복되지 않게하면 순열이 됨.
function solution2 (n, m) {
    let answer = [];
    let tmp = [];
    let check = Array.from({length: n+1}, () => 0); // 0으로 초기화한 배열

    function DFS (L) {
        if (L === m) {
            answer.push(tmp.slice());
        } else {
            for (let i = 1; i <= n; i++) {
                if (check[i] === 0) { // 0 체크 배열을 활용해 사용여부 체크
                    check[i] = 1; // 조건문을 만족했으면 사용하게 되므로 다시 1로 변환
                    tmp.push(i);
                    DFS(L + 1); // 레벨은 단순히 m 레벨에서 멈추게 하기 위한 용도
                    tmp.pop();
                    check[i] = 0; // 제거된 후에는 다시 사용여부 0으로 변환
                }
            }
        } 
    }
    DFS(0);
    return answer;
}
console.log(solution2(3, 2));
```

### 참고사항

<details>
<summary></summary>
<div markdown="1">       
반복문으로 짠다면 트리 레벨이 증가할수록 for 반복문을 증가시켜야 합니다. <br>
반면에 재귀는 어떤 레벨에서 멈출건지 정해주면 상대적으로 유연한 사용이 가능합니다.
</div>
</details>
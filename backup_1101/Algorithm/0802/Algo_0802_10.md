---
date: '2021-08-02'
title: '[JS Algo] 수열 추측하기'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 수열 추측하기

<details>
<summary></summary>
<div markdown="1">       
가장 윗 줄에 1부터 N까지 숫자가 있고 둘째 줄부터는 파스칼 삼각형과 같이 윗 줄의 두 개 값을 더한 값을 저장합니다. 입력으로 N과 가장 밑에 있는 숫자가 주어졌을 때, 가장 윗줄에 있는 숫자의 나열을 구해야 합니다.<br>
단, 답이 여러 가지가 나올 경우 사전순으로 가장 앞에 오는 것을 출력합니다.
</div>
</details>

## A. 풀이
1부터 n까지 숫자로 이루어진 순열을 구해야 하는 문제입니다. 가장 밑에 있는 숫자는 가장 위에 있는 숫자들 조합의 합입니다.<br>
ex) 16 = 3 + 1 + 1 + 1 + 2 + 2 + 2 + 4 <br>
각 숫자들은 1, 3, 3, 1 번 사용되었고, 이는 (4-1)_C_(0), ..., (4-1)_C_(4-1) 와 같습니다. 숫자 n에 대해 일반화하면 (n-1)_C_(0), ..., (n-1)_C_(n-1)이 됩니다.<br>
이 조합값들을 구하고, 1부터 n까지 숫자들의 순열을 구하게 되는데, 어떤 순열이 조합값들과의 곱의 합을 통해 마지막 숫자가 도출되는지를 찾아내면 됩니다.   

```javascript
function solution (n, f) {
    let answer = 0;
    let flag = false;
    let dy = Array.from(Array(11), () => Array(11).fill(0)); // 메모이제이션을 위한 2차원 배열
    let check = Array.from({length: n + 1}, () => 0);
    let p = [], b = [];

    function combination (n, r) {
        if (dy[n][r] > 0) return dy[n][r]; // 0보다 크면 2차원 배열에 값이 있다는 의미이므로 재사용
        if (n === r || r === 0) {
            return 1;
        } else {
            return dy[n][r] = combination(n - 1, r - 1) + combination(n - 1, r); // n, r이 2차원 배열의 (n,r) 원소가 된다.
        }
    }

    function DFS (L, sum) {
        if (flag) return;
        if (L === n) {
            if (sum === f) {
                answer = p.slice();
                flag = true;
            }
        } else {
            for (let i = 1; i <= n; i++) {
                if (check[i] === 0) {
                    check[i] = 1;
                    p.push(i);
                    DFS(L + 1, sum + (p[p.length-1] * b[L]));
                    check[i] = 0;
                    p.pop();
                }
            }
        }
    }
    for (let i = 0; i < n; i++) {
        b.push(combination(n - 1, i));
    }
    DFS(0, 0)
    return answer;
}
console.log(solution(4, 16)) // [3, 1, 2, 4]
console.log(solution(5, 50)) // [1, 2, 4, 3, 5]

// 조합값을 다른 방식으로 구한 것
// (b[i - 1] * (n - i))/i
function solution2 (n, f) {
    let answer = 0;
    let flag = false;
    let check = Array.from({length: n + 1}, () => 0);
    let p = [], b = [];

    function DFS (L, sum) {
        if (flag) return;
        if (L === n) {
            if (sum === f) {
                answer = p.slice();
                flag = true;
            }
        } else {
            for (let i = 1; i <= n; i++) {
                if (check[i] === 0) {
                    check[i] = 1;
                    p.push(i);
                    DFS(L + 1, sum + (p[p.length-1] * b[L]));
                    check[i] = 0;
                    p.pop();
                }
            }
        }
    }
    b.push(1);
    for (let i = 1; i < n; i++) {
        b.push((b[i - 1] * (n - i))/i);
    }
    DFS(0, 0)
    return answer;
}
console.log(solution2(4, 16)) // [3, 1, 2, 4]
console.log(solution2(5, 50)) // [1, 2, 4, 3, 5]
```
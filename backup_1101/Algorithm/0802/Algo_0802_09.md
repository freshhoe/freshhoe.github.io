---
date: '2021-08-02'
title: '[JS Algo] 조합의 경우수 (메모이제이션)'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 조합의 경우수 (메모이제이션)

<details>
<summary></summary>
<div markdown="1">       
매개변수 n 과 r 이 주어졌을 때, n 개 중 r 개를 뽑아 만들 수 있는 조합의 수를 반환해야합니다.
</div>
</details>

## A. 풀이
조합을 구하는 공식을 다르게 표현하면 재귀를 사용해 구할 수 있습니다. `n C r = n-1 C r_1 + n-1 C r` 로 나타낼 수 있습니다. 예를 들어 다섯 명의 학생 중 3명 뽑는 조합의 수를 나타낸다면 5C3 = 4C2 + 4C3 로 나타낼 수 있고, 이것의 의미는 특정 학생을 기준으로 그 학생을 포함한 것, 포함하지 않은 것의 조합을 구분지어 더한 것입니다. <br>
재귀도 이 공식의 형태로 구성하고, 중단 조건은 `n` 과 `r` 이 같거나, `r` 이 `0` 이 되어 `1` 값을 가지게 되는 경우입니다. <br>
`n` 이 커질수록 재귀를 통해 찾아야 하는 값이 많아져 시간이 오래걸릴 수 있는데, 이 때는 메모이제이션을 활용하면 시간을 단축시킬 수 있습니다. 메모이제이션은 말그대로 우리가 이미 구한 값을 저장해뒀다가 필요할 때 다시 계산하지 않고 재사용하는 것을 의미합니다. <br>
`0` 으로 초기화 된 2차원 배열에 재귀를 통해 계산된 조합식 값을 저장하고, 해당 값이 필요할 때마다 재사용할 수 있는 조건을 추가합니다.

```javascript
function solution (n, r) {
    let answer = 0;

    function DFS (n, r) {
        if (n === r || r === 0) {
            return 1;
        } else {
            return DFS(n - 1, r - 1) + DFS(n - 1, r);
        }
    }
    answer = DFS(n, r);
    return answer;
}
console.log(solution(5, 3)); // 10
console.log(solution(33, 19)); // 818809200

// DP 를 재귀를 이용해 풀 때, 메모이제이션을 활용해 볼 수 있다.
// 조합의 경우수 (with 메모이제이션)
function solution2 (n, r) {
    let answer = 0;
    let dy = Array.from(Array(35), () => Array(35).fill(0)); // 메모이제이션을 위한 2차원 배열

    function DFS (n, r) {
        if (dy[n][r] > 0) return dy[n][r]; // 0보다 크면 2차원 배열에 값이 있다는 의미이므로 재사용
        if (n === r || r === 0) {
            return 1;
        } else {
            return dy[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r); // n, r이 2차원 배열의 (n,r) 원소가 된다.
        }
    }
    answer = DFS(n, r);
    return answer;
}
console.log(solution2(5, 3)); // 10
console.log(solution2(33, 19)); // 818809200
```

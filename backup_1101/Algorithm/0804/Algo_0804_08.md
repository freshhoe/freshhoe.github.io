---
date: '2021-08-04'
title: '[JS Algo] 제품 이동'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 제품 이동

<details>
<summary></summary>
<div markdown="1">       
매개변수 N 에는 섬의 개수가 주어집니다. 매개변수 edges 에는 다리로 연결된 두 섬의 번호와 무게제한이 주어집니다. 매개변수 s와 e에는 공장이 존재하는 섬의 번호가 주어집니다. <br>
두 공장에서 제품을 옮긴다고 할 때, 한 번의 이동으로 옮길 수 있는 최대 무게를 반환해야 합니다.
</div>
</details>

## A. 풀이

제품의 무게는 1 보다 작을 수 없고, 가중치의 최대값을 넘어갈 경우 이동이 불가하므로 해당 값을 넘어갈 수 없습니다. 옮기는 제품의 무게를 매개변수로 하는 `BFS` 를 통해 경로를 탐색합니다. 탐색 완료 후 도착지점이 방문 처리 되어 있다면 해당 무게로 이동이 가능하다는 것을 의미합니다. 따라서 `BFS` 의 반환값은 도착지점의 방문 여부를 나타내는 1 또는 0 값이며, 방문하지 못했을 경우(0 인경우)에는 옮기는 제품의 무게를 줄이고 방문했을 경우에는 옮기는 제품의 무게를 늘려 탐색을 재진행합니다.<br>
인접리스트를 활용한 가중치 그래프를 생성합니다. 해당 그래프를 생성하며 `binary search` 의 최대값 초기화를 진행합니다. 인접리스트에서 s 공장이 위치하는 섬 번호에 해당하는 배열을 `queue` 에 삽입합니다. 해당 위치와 연결된 섬의 번호와 가중치를 받아 방문하지 않은 섬이고, 무게가 가중치를 넘지 않는 경우에는 이동이 가능하다는 의미이므로 방문처리 후 해당 섬 번호를 `queue` 에 삽입합니다. 이 과정을 또 다른 공장이 위치하는 섬 번호가 방문처리 될 때까지 반복합니다.

```javascript
function solution(N, edges, s, e) {
  let answer;
  let n = edges.length;
  let graph = Array.from(Array(n), () => Array());
  let lt = 1;
  let rt = 0;

  for (let [a, b, c] of edges) {
    graph[a].push([b, c]);
    graph[b].push([a, c]);
    rt = Math.max(rt, c);
  }

  function BFS(w) {
    let check = Array.from({ length: n + 1 }, () => 0);
    let queue = [];
    check[s] = 1;
    queue.push(s);

    while (queue.length) {
      let curr = queue.shift();
      for (let [b, c] of graph[curr]) {
        if (c >= w && check[b] === 0) {
          check[b] = 1;
          queue.push(b);
        }
      }
    }
    return check[e]; // 도착지점이 1이면 방문한 것.
  }

  while (lt <= rt) {
    let mid = parseInt((lt + rt) / 2);
    if (BFS(mid)) {
      answer = mid;
      lt = mid + 1;
    } else {
      rt = mid - 1;
    }
  }
  return answer;
}
console.log(
  solution(
    5,
    [
      [1, 2, 5],
      [1, 3, 3],
      [1, 4, 2],
      [2, 4, 2],
      [3, 4, 4],
      [4, 5, 3],
    ],
    1,
    5,
  ),
); // 3
```

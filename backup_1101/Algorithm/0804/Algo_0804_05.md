---
date: '2021-08-04'
title: '[JS Algo] 랜선자르기 (결정알고리즘)'
categories: ['Algorithm', 'JavaScript']
summary: ''
thumbnail: './Algorithm.png'
---

## Q. 랜선자르기 (결정알고리즘)

<details>
<summary></summary>
<div markdown="1">       
매개변수 nums 에 기존에 보유하고 있는 K 개의 랜선의 길이가 주어집니다. 매개변수 n 에 새롭게 만들어야 할 랜선의 갯수가 주어집니다. nums 에 주어진 랜선을 잘라 N 개의 랜선을 만들어야 했을때, 자른 랜선의 최대 길이를 반환해야 합니다. (n 개 보다 많이 만드는 것도 허용됩니다.)  
</div>
</details>

## A. 풀이
`binary search` 를 활용한 결정 알고리즘은 어떤 문제의 답이 우리가 상정할 수 있는 어떤 최소값, 최대값 사이에 존재한다는 것이 확실시 될 때 사용할 수 있습니다. `binary search` 를 통해 최적의 방향이 어딘지를 판단하는 것은 문제 상황에서 주어진 조건에 따라 다릅니다. 따라서 이 조건을 검증하기 위한 값을 도출하는 함수를 별도로 구현해 사용하는 것이 좋습니다. 이 함수에서 도출된 값을 `binary search` 를 반복하며 최적화 해나가면 됩니다. <br>
이 문제에서 요구하는 것은 n 개 이상의 랜선을 만들 수 있게하는 자른 랜선의 최대 길이입니다. 보유하고 있는 K개의 랜선의 길이를 각각 자른 랜선의 길이로 나눴을 때 몫이, 각 랜선 길이별로 만들 수 있는 새로운 랜선의 갯수입니다. 이것을 도출하는 함수를 별도로 구현합니다. <br>
우리가 구하는 최적의 랜선 길이는 `1 ~ 802`(입력 변수 배열의 최대값) 사이에는 분명히 있다는 것을 확실히 알 수 있습니다. 따라서 `binary search` 시작지점과 끝지점을 각각 1과 802로 초기화합니다.<br> 
함수를 통해 나온 값이 N 개 이상인지를 확인하며 `binary search` 를 반복해 최적의 값을 찾습니다.

```javascript
function solution (nums, n) {
    let answer;
    let lt = 1;
    let rt = Math.max(...nums);

    function count (len) {
        let cnt = 0;
        for (let x of nums) {
            cnt += Math.floor(x / len);
        }
        return cnt;
    }

    while (lt <= rt) {
        let mid = parseInt((lt + rt) / 2);
        if (count(mid) >= n) {
            answer = mid;
            lt = mid + 1;
        } else {
            rt = mid - 1;
        }
    }

    return answer;
}
console.log(solution([802, 743, 457, 539], 11)); // 200
```
{"componentChunkName":"component---src-templates-post-template-tsx","path":"/JavaScript/0906/JavaScript_0906/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<!-- ![](./images/.PNG) -->\n<h2>첫 번째 시간</h2>\n<ul>\n<li>코드를 짜면 되면 왜 되는지, 안되면 왜 안되는지 설명할 줄 알아야 한다.</li>\n<li>성장가능성이 높은 사람이 신입으로서 좋은 개발자라고 할 수 있다.</li>\n<li>유지보수가 가능한 좋은 코드를 만들 수 있는 개발자를 선호하게 되었기 때문에, 성장가능성이 높은 사람을 뽑아야 계속해서 좋은 코드를 만들어 나갈 수 있다.</li>\n<li>성장가능성이 높으려면 기본기가 갖춰져야 한다.</li>\n<li>그리고 신입사원으로서의 기본기라함은 태도다. 여기서 태도는 개발이라는 업을 어떻게 바라보느냐 등을 말한다.</li>\n</ul>\n<hr>\n<h2>두 번째 시간</h2>\n<ul>\n<li>에러가 나면 애플리케이션이 스탑된다. 즉, 에러난 부분부터 실행이 안된다. 그러나 자바스크립트는 웬만해서는 에러없이 실행된다. 예를 들어,</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> a<span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">var</span> a<span class=\"token punctuation\">;</span></code></pre></div>\n<p>와 같이 중복 선언을 하면 보통 다른 언어는 두 번째 선언에서 에러로 인해 실행이 중단되지만 자바스크립트는 알아서 대응해서 실수로 인식하고 넘어간다.</p>\n<ul>\n<li>이러한 암묵적인 처리해 주는 기능(magic)을 이해하고 넘어가야 코드를 정확하게 읽을 수 있다.</li>\n<li>한 가지 알고가야 할 것은 에러는 런타임 전에 좀 더 원활하게 발생되어야 디버깅할 수 있게 하는 것이 좋다.</li>\n<li>런타임 : 코드가 동작하는 시점. 인터프리터에 의해 한 줄, 한 줄 실행되는 시점.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token number\">1</span> <span class=\"token operator\">==</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\r\n<span class=\"token number\">1</span> <span class=\"token operator\">===</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token function\">String</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\na<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\na <span class=\"token operator\">+</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">// 이렇게 문자열 변환 방식이 여러개인데 이런 방식을 다 알고 가장 적절한 방식이 뭔지 알고 사용해야 한다.</span>\r\n<span class=\"token comment\">// a.toString(); 은 a가 원시값인데도 객체 메서드를 사용할 수 있는 이유는 무엇일까?</span></code></pre></div>\n<ul>\n<li>\n<p>자바스크립트는 동적 타입 언어라는 약점이 있다. 변수 선언시 타입을 지정하지 않아도 어떤 값을 할당하냐에 따라 동적으로 타입이 정해진다.</p>\n</li>\n<li>\n<p>모던한 자바스크립트 개발 환경은 선언형 개발을 추구한다. 대표적으로 React가 있다. 가독성을 높이기 위해 조건문과 반복문 같은 제어문 사용을 지양하는? 방식. 반대의 개념은 절차형 개발이 있다.</p>\n</li>\n</ul>\n<hr>\n<h2>세 번째 시간</h2>\n<ul>\n<li>에버그린 브라우저 : 브라우저의 버전을 자동으로 업데이트? 하는 브라우저.</li>\n</ul>\n<p><strong>Ajax</strong></p>\n<ul>\n<li>\n<p>비동기(asynchronous) : 애플리케이션을 만들면 서버의 DB로부터 데이터를 가져오게 될텐데, 서버는 물리적으로 떨어져 있기 때문에 가져오는 과정에서 딜레이가 발생한다. 그렇다면 이렇게 딜레이가 발생한 시간동안 어떻게 할 것인가? 이 때 비동기 방식을 사용한다. 데이터가 필요한 부분은 놔두고 다른 부분부터 렌더링 등의 작업을 수행해서 디스플레이를 먼저하는 것을 말한다.\r\n자바스크립트의 특징인 싱글 스레드와 이벤트 루프 등의 개념을 부가적으로 이해해야 한다.</p>\n</li>\n<li>\n<p>데스크탑 애플리케이션(StandAlone) : 어떤 것이든 트레이드오프가 존재. 데스크탑 애플리케이션의 장점이라면 빠른 성능과 부드러운 화면 전환이 있겠다. 단점이라면 설치라는 과정을 거쳐야 하고, 업데이트를 해줘야 할 때 사용자에게 별도의 과정을 안내 및 강제해야 한다.</p>\n</li>\n<li>\n<p>웹 애플리케이션은 설치라는 과정이 필요없고, 업데이트를 했는지 안했는지도 모르게 할 수 있어서 새로운 기능을 추가하면 자연스럽게 사용자가 이용할 수 있도록 하게 할 수 있다. 또한 불법 복제를 방지할 수 있고, 유지 보수 측면에서도 관리가 편하다. 예전에는 브라우저의 목적이 웹 사이트를 뷰잉하는 것일 뿐이었기 때문에 성능 자체가 느렸다. 성능을 높이기 위해서는 브라우저 렌더링 엔진과 자바스크립트 엔진을 동시에 개선시켜야 했다. 이러한 목적으로 탄생한 자바스크립트 엔진이 V8 엔진이고 이것을 탑재한 브라우저가 크롬 브라우저다.</p>\n</li>\n</ul>\n<p><strong>Node.js</strong></p>\n<ul>\n<li>백엔드(서버 사이드) 쪽에서 동작하는 언어는 여러가지가 있었지만, 브라우저(클라이언트 사이드)에서 동작할 수 있는 언어는 자바스크립트가 유일했다. 이러한 종속성에서 벗어나 백엔드에서도 자바스크립트를 동작하게 하기 위해 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이 Node.js다.</li>\n</ul>\n<p><strong>SPA</strong></p>\n<ul>\n<li>\n<p>SPA라는 것은 클라이언트 사이드 렌더링의 의미를 내포하고 있다. 요즘의 트렌드 중 하나는 서버사이드 렌더링이 되었기 때문에, SPA는 조금 예전의 사용되던 단어로 볼 수 있다. 참고로 서버 사이드 렌더링은 실제로 그려주는 과정까지는 포함되지 않는다.</p>\n</li>\n<li>\n<p>CBD(Component Based Development) : HTML, CSS, Script를 하나의 덩어리로 보고 재사용성을 고려해 구분지은 단위를 Component라고 한다. 그러나 이것을 적절하게 쪼개는 것은 쉽지 않다. 과연 단지 두 번만 사용하는 것을 재사용으로 보고 컴포넌트로 구분해야 하는 걸까? 하는 것과 같은 고민들이 이어질 수 있다.</p>\n</li>\n</ul>\n<hr>\n<h2>네 번째 시간</h2>\n<p><strong>발표1</strong></p>\n<ul>\n<li>\n<p>인터프리터와 컴파일러의 차이점에 대한 발표. 순서 없음. 했던 사람 또 할 수도.</p>\n</li>\n<li>\n<p>참고 : 선언형은 함수형 언어보다 큰 개념이다.</p>\n</li>\n<li>\n<p>for문(명령형)은 지양해야 한다. 가독성 측면에서 좋지 않다. 물론 효율성 측면에서는 빠르다. 그러나 꼭 for문을 그렇게 많이 돌려야 결과가 나오는 건가? 에 대해서는 한 번 더 생각해봐야 한다. 필요한 것만 뽑아서 결과를 도출하면 굳이 반복문을 많이 돌릴 필요가 없다.</p>\n</li>\n<li>\n<p>현재 단계에서는 개발할 때 효율성보다는 가독성에 치중해야 한다.</p>\n</li>\n</ul>\n<p><strong>변수</strong></p>\n<ul>\n<li>메모리 공간에 저장되어 있지 않은 것은 값이 아니다.</li>\n<li>값은 최소 8비트(하나의 메모리 셀)의 용량을 차지한다. true, false도 하나의 메모리 셀을 차지한다. 용량의 낭비보다 코드의 가독성을 우선시하기 때문.</li>\n<li>이진수로 저장이된다고 논리적으로 이해하자. 실제로는 전압의 차이가 기록된다.</li>\n</ul>\n<p><strong>발표2</strong></p>\n<ul>\n<li>\n<p>왜 하나의 메모리 셀이 8비트(8개의 방?)인가? 아스키코드와 유니코드를 함께 조사해보면 도움이 될듯</p>\n</li>\n<li>\n<p>값을 생성하는 방법 중 가장 기본적인 방법은 리터럴이다. 리터럴은 사람도 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.</p>\n</li>\n<li>\n<p>어떤 프로그램을 만들면 모두 Input -> Process -> Output 의 과정을 거친다. IPO 모델이라 한다. 좀 더 복잡한 형태는 상태가 여기에 관여할 수 있다. Input으로 주어진 값 외에 외부 변수 x를 추가로 사용한다면 상태가 새롭게 주어졌다고 하고 비순수함수라고 부른다.</p>\n</li>\n<li>\n<p>메모리 셀에 값을 배정하는 권한은 OS의 권한이고, 자바스크립트 엔진은 이것을 OS에게 요청한다.</p>\n</li>\n<li>\n<p>메모리에서 값을 가져와서 CPU에서 연산하려면 가져온 값을 저장하는 CPU의 메모리가 있어야 한다. 이러한 메모리의 종류로 캐시 메모리, 레지스트 메모리가 있다.</p>\n</li>\n<li>\n<p>대부분의 언어는 메모리셀의 주소를 알려주지 않는다. 사람은 실수한다는 전제가 기본 바탕에 있기 때문에.</p>\n</li>\n<li>\n<p>변수 선언. 자바스크립트 엔진에게 어떤 변수를 사용하겠다고 알리는 것. 그래서 ‘메모리 공간의 일부분을 확보해라’ 라는 명령. 그럼 얼마만큼의 공간을 확보해야 하는 걸까? 언어마다 다르다. 타입을 선언하는 언어는 선언한 타입의 크기가 확보해야 할 공간의 기준이 된다. 자바스크립트는 선언시 정해진 타입이 없는 동적 타입 언어다. 따라서 <code class=\"language-text\">undefined</code> 라는 값을 만들어내서 이 값이 들어갈만한 공간을 확보한다. 그러면 <code class=\"language-text\">undefined</code>는 얼마만큼의 공간을 차지하는가? 모른다. 표준 사양(ECMAScript)에 명시되어 있지 않기 때문에 브라우저마다 다르다.</p>\n</li>\n<li>\n<p>변수의 이름(더 큰 포함관계로 보면 식별자)과 메모리 선두 address는 1:1 매핑 관계에 있다. 이러한 매핑관계가 기계어 레벨에서 처리되므로 자바스크립트 엔진도 정확히 파악하고 있지 않다. 여기서 기계어 레벨이란 어셈블리어를 말한다.</p>\n</li>\n<li>\n<p>참고 : HTML의 식별자(id)는 유니크하지 않아서 유일하게 구별해내지 못한다.</p>\n</li>\n<li>\n<p>함수형 언어에서는 함수도 값이다. 자바스크립트는 함수형 언어로써의 기능도 한다. 따라서 함수명도 식별자다. 값으로 메모리에 할당되므로.</p>\n</li>\n<li>\n<p>프로그래밍 언어에서 식별자는 스코프 내에서 유니크해야 한다. 파일명이 하나의 폴더 내에서 유니크한 것처럼.</p>\n</li>\n</ul>\n<hr>\n<h2>다섯 번째 시간</h2>\n<ul>\n<li>메모리 공간을 확보한다(allocate)는 의미는 메모리 공간에 값이 할당되면 그 공간에 롹을 걸어서 다음 공간 확보시에 스킵할 수 있게 한다는 의미.</li>\n<li>확보를 했으면 해제를 해야한다. 해제를 하지 않으면 필요없는 값도 롹이 걸린 상태로 메모리 공간을 차지하기 때문에 낭비가 일어나기 때문.</li>\n<li>자바스크립트는 비개발자를 고려하고 만든 언어이기 때문에 개발자가 메모리 공간을 매니징하는게 아니라 가비지 컬렉터라고 하는 것을 내장에서 알아서 매니징하도록 하는 언어. 이러한 언어를 매니지드 언어라고 한다.</li>\n</ul>\n<p><strong>발표3 가비지 컬렉터</strong></p>\n<ul>\n<li>\n<p>이것도 조사 발표. 알고리즘까지 조사할 필요는 없다.</p>\n</li>\n<li>\n<p>기본적인 알고리즘만 말하자면, 사용하고 있지 않은 메모리 공간만 롹을 풀면되는데 이것을 파악하는 방법이라 하면, 사용되었다가 이후에 사용되지 않는것을 찾으면 된다. 이 말인즉슨 변수가 소멸했을 때를 찾으면 된다는 말. 변수는 언제 태어나고 언제 소멸되는가? 이후에 스코프 관련해서 이야기 할 부분.</p>\n</li>\n<li>\n<p>메모리는 공간의 값을 지운다는 개념은 없다고 보면되고, 쓴다라는 개념만 있다. 덮어쓴다도 쓴다의 개념.</p>\n</li>\n<li>\n<p>원시값은 불변이다. 메모리 공간에 이미 있는 값을 덮어쓰지 않는다는 의미다. 따라서 변수에 값을 할당 후 재할당시에 기존 값을 변경하는 것이 아니라 새로운 공간에 값을 채워넣고 변수의 메모리 주소만 새로운 공간의 메모리 주소로 변경하는 것.</p>\n</li>\n<li>\n<p>변수에 최초로 값을 할당하는 것을 초기화라고 한다. 자바스크립트가 암묵적으로 하는 하는 것은 초기화라고 부르지는 않는다. 실제로는 <code class=\"language-text\">undefined</code>로 되었지만.</p>\n</li>\n<li>\n<p>변수 hoisting은 선언문이 끌어올려져 실행된다는 의미가 직관적이기는 하지만 좀 더 정확하게는 런타임 이전에 선언문이 먼저 실행된다는 것으로 보게는 맞다. 그럼 왜 호이스팅을 허용했을까? 자바스크립트 탄생 배경에는 왠만해서는 에러를 발생시키지 않는다는 목적이 있었기 때문. 이것이 <code class=\"language-text\">var</code> 선언문의 안 좋은 점 중 하나. 그래서 <code class=\"language-text\">let</code>, <code class=\"language-text\">const</code>가 탄생한 것. 그럼 <code class=\"language-text\">let</code>, <code class=\"language-text\">const</code>는 호이스팅이 발생하지 않나? 발생은 하지만 발생하지 않은것처럼 동작.</p>\n</li>\n<li>\n<p>선언시에 <code class=\"language-text\">undefined</code>를 넣는 이유는 메모리 공간에 이미 값이 있는 쓰레기(garbage)값이 개발자의 의도와 상관없이 사용되어 변수에 할당될 수 있기 때문. 따라서 <code class=\"language-text\">undefined</code> 으로 초기화하는 것.</p>\n</li>\n<li>\n<p>예습범위 : 6 ~ 9. 타입 변환과 단축 평가</p>\n</li>\n<li>\n<p>내일 러버덕 범위는 1 ~ 5</p>\n</li>\n<li>\n<p>모레 러버덕은 오늘 예습 범위</p>\n</li>\n<li>\n<p>발표 조사</p>\n</li>\n</ul>\n<ol>\n<li>인터프리터와 컴파일러의 차이점</li>\n<li>왜 하나의 메모리 셀이 8비트(8개의 방?)인가? 아스키코드와 유니코드를 함께 조사해보면 도움이 될듯</li>\n<li>가비지 컬렉터</li>\n</ol>\n<ul>\n<li>TIL은 블로그에 공개적으로 올리지 않는 것을 추천. TIL을 쓰는 것은 머리속에 있는 것을 정리한다는 목적이어야 한다. 차라리 하나의 주제로 좀 더 깊이있게 포스팅하는 것이 좋다.</li>\n</ul>","frontmatter":{"title":"1. JavaScript TIL","summary":"","date":"2021.09.06.","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y+2SP2gTYRjG315ztrnGpN4lZ4N33/tdbKWDo6AOlg6iIOggFFdnwVVwFOqfwVZsSyuikEgFHRy0oFAQOjtUI4pacxfTJE3OC4TW3NVeLvkkPRAtyaCTgx8v3/DAj+d9Xh7YzJK/HvgP/4Pwt0zrd3OkphNb/xPYMQgzqW2Q6ge1UUaviI7RAXYM4q4S6516fKR37LSwsaKyEs5eF4cH+QG5++wp4f1S3Mu3+Pawl8e1N0o4xGkk0CjgQioGAAOx7qOHegDg/LkQM9HWO8D1PJbTirSH248BVqGXL0YAIDkbZV5iISUXlhV3lTjZzs6ltNIf5hIYYCVM3o4CwMHhXY/mot+L2LSonemQ2dZbzj48qPEbn8nmFzJ2RoDtd0DjXzyUWbnd2rZOtnJY387cH+GGEvz6J7VeRNeiz1LyidEgAAjBrteLcbaGsGPhponlt0rTxGpGjUS4IY2v6aT6UV1ejDNbY/XEpQthAJgeF1mFwq+ezMT7k1J4Nzc1Lt69KQHAyJFer4DHDvfwAZi+Ki492eubz89IzNoBl/FpUu4TOD8ex8HjOzFWpXM3xFBfl68AwMnR4PqKupX7PbOjE/aVZl/tuzchzVwT0y/jzVLrML74YCp664r4fF52ssTNkzYl8U/NLMoqtFFEv8a1n6JFmUkdg/j1/AEBC6bLcXen9gAAAABJRU5ErkJggg==","aspectRatio":1,"src":"/static/8155d983e2c1460e10661d6945336f58/fe9a8/JS.png","srcSet":"/static/8155d983e2c1460e10661d6945336f58/a9f05/JS.png 200w,\n/static/8155d983e2c1460e10661d6945336f58/fe9a8/JS.png 225w","srcWebp":"/static/8155d983e2c1460e10661d6945336f58/91996/JS.webp","srcSetWebp":"/static/8155d983e2c1460e10661d6945336f58/8444f/JS.webp 200w,\n/static/8155d983e2c1460e10661d6945336f58/91996/JS.webp 225w","sizes":"(max-width: 225px) 100vw, 225px"}},"publicURL":"/static/8155d983e2c1460e10661d6945336f58/JS.png"}}}}]}},"pageContext":{"slug":"/JavaScript/0906/JavaScript_0906/"}},"staticQueryHashes":[]}